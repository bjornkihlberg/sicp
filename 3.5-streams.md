- [3.5  Streams](#35-streams)
  - [3.5.1  Streams Are Delayed Lists](#351-streams-are-delayed-lists)
  - [3.5.2  Infinite Streams](#352-infinite-streams)
  - [3.5.3  Exploiting the Stream Paradigm](#353-exploiting-the-stream-paradigm)
  - [3.5.4  Streams and Delayed Evaluation](#354-streams-and-delayed-evaluation)
  - [3.5.5  Modularity of Functional Programs and Modularity of Objects](#355-modularity-of-functional-programs-and-modularity-of-objects)

# 3.5  Streams

This section offers an alternative to organizing our programs with stateful objects. The alternative is using streams; lazy (possibly infinite) sequences that allows us to declaratively describe the state of a program.

## 3.5.1  Streams Are Delayed Lists

We can use `lambda` to *delay* evaluation of a value. If we `cons` a value with a `lambda` we essentially postpone evaluation of the tail of the list.

```scheme
(define xs (lambda () (cons 5 (lambda () (cons 10 (lambda () '()))))))

(define (stream-null? s) (null? (s)))
(define (stream-car s) (car (s)))
(define (stream-cdr s) (cdr (s)))

(define (stream-ref s n)
  (cond ((> 0 n) #f)
        ((stream-null? s) #f)
        ((= n 0) (stream-car s))
        (else (stream-ref (stream-cdr s) (- n 1)))))

(define (stream-map f s)
  (if (stream-null? s)
      s
      (lambda () (cons (f (stream-car s)) (lambda () (stream-map f (stream-cdr s)))))))

(define (stream-filter f s)
  (cond ((stream-null? s) s)
        ((f (stream-car s))
          (cons (stream-car s)
                (lambda () (stream-filter f (stream-cdr s)))))
        (else (stream-filter f (stream-cdr s)))))

(stream-ref xs 1) ; 10

(define ys (stream-map (lambda (x) (* x 3)) xs))

(stream-ref ys 1) ; 30

(stream-filter even? xs) ; (10 . #<procedure>)
```
*This code doesn't work. I give up because I keep running into problems due to a lack of a static type system. Note that this is only 30 LOC and development is already intolerable. Hopefully a static type system can be implemented in LISP in some way.*

There is a special form `delay` which is like a lambda but is evaluated with `force`. Subsequent calls to `force` on the same *delayed object* doesn't reevaluate the expression.

```scheme
(define lazy-value
  (delay (begin
    (display "I'm being evaluated!\n")
    (* 3 5))))

(force lazy-value) ; prints "I'm being evaluated! and returns 15
(force lazy-value) ; returns 15
(force lazy-value) ; returns 15
```
*`begin` allows us to perform effects before returning a value*

Using either `lambda` or `delay` we can choose whether a value should be cached or not. There are situations when we only consume a value once, we may not want the value stored in memory.

As a side note, it's interesting that `delay` can decide whether its subexpressions should be evaluated lazily or strictly.

## 3.5.2  Infinite Streams

Since streams are lazy we can describe infinite streams.

```scheme
(define (iterate f i)
  (cons i (lambda () (iterate f (f i)))))
```
*`iterate` is a procedure that builds an infinite stream based on some starting value for `i`.*

## 3.5.3  Exploiting the Stream Paradigm

This section has some interesting ideas around using streams as signals which basically underlies the functional reactive programming paradigm.

## 3.5.4  Streams and Delayed Evaluation

This section mentions an interesting problem of combining laziness with effectful computations. I believe this book was written in the 80's before Haskell discovered how monads can combine these two aspects.

## 3.5.5  Modularity of Functional Programs and Modularity of Objects

Another comparison of object oriented programming and functional programming.
