- [1.3 Formulating Abstractions with Higher-Order Procedures](#13-formulating-abstractions-with-higher-order-procedures)
  - [1.3.1 Procedures as Arguments](#131-procedures-as-arguments)
  - [1.3.2 Constructing Procedures Using `lambda`](#132-constructing-procedures-using-lambda)
  - [1.3.3 Procedures as General Methods](#133-procedures-as-general-methods)
  - [1.3.4 Procedures as Returned Values](#134-procedures-as-returned-values)

# 1.3 Formulating Abstractions with Higher-Order Procedures

## 1.3.1 Procedures as Arguments

This section shows how higher order functions can be used to produce highly generic abstractions. An example not shown in the book is the `fold-left`-function.

```scheme
(fold-left + 0 '(1 2 3))
```

`fold-left` accepts a function as an argument, in this case `+`. It is a function in common use in functional programming to prevent the need for complicated loops. It abstracts the generic concept of building up a result from a list.

## 1.3.2 Constructing Procedures Using `lambda`

This section shows how to make procedure values with the `lambda` keyword.

```scheme
; A cubing function applied on the argument 3
((lambda (x) (* x x x)) 3)
```

The section also demonstrates the useful special form `let` for creating locally scoped variables and using them. All in one single expression.

```scheme
; the expression evaluating to 12
(let ((a 5)
      (b 7))
  (+ a b))
```

## 1.3.3 Procedures as General Methods

This section demonstrates who procedures can be made to automate solving mathematical problems. Again, I'm not going to get into it here.

## 1.3.4 Procedures as Returned Values

This section shows how a procedure can return another procedure. This can serve as a functional alternative to object orientation where we can provide some data to a procedure (what's called a *constructor* in OOP) to get back other procedures operating on that data. A simple example is a procedure producing another procedure for incrementing.

```scheme
(define (incrementor n)
  (lambda (x) (+ x n)))

(define inc1 (incrementor 1))
(define inc7 (incrementor 7))

; returns 7
(inc1 6)

; returns 13
(inc7 6)
```
