- [1.1 The Elements of Programming](#11-the-elements-of-programming)
  - [1.1.1 Expressions](#111-expressions)
  - [1.1.2 Naming and the Environment](#112-naming-and-the-environment)
  - [1.1.3 Evaluating Combinations](#113-evaluating-combinations)
  - [1.1.4 Compound Procedures](#114-compound-procedures)
  - [1.1.5 The Substitution Model for Procedure Application](#115-the-substitution-model-for-procedure-application)
    - [Applicative order versus normal order](#applicative-order-versus-normal-order)
  - [1.1.6 Conditional Expressions and Predicates](#116-conditional-expressions-and-predicates)
  - [1.1.7 Example: Square Roots by Newton's Method](#117-example-square-roots-by-newtons-method)
  - [1.1.8 Procedures as Black-Box Abstractions](#118-procedures-as-black-box-abstractions)

# 1.1 The Elements of Programming

This chapter goes over basics of programming.

- primitive expressions
- means of combination
- means of abstraction

## 1.1.1 Expressions

This section covers how expressions evaluates to something and how they can be combined to form more complex expressions.

```scheme
; A primitive expression 5 evaluating to itself
5
```

```scheme
; A compound expression evaluating to 11
(+ 1 (* 2 3) 4)
```

## 1.1.2 Naming and the Environment

This section covers variables.

```scheme
; Associate the value 5 with the name x
(define x 5)

; An expression referencing x evaluating to 25
(* x x)
```

## 1.1.3 Evaluating Combinations

This section explains how combound expressions are evaluated. It is explained that a compound expression is evaluated *inside out* like shown in the sequence of expressions below.

```scheme
(+ 1 (* 2 3) 4)

(+ 1 6 4)

11
```

However it is noted `define` is not evaluated in this way. `define` s noted as being an example of a *special form*. Therefore the following is not a combination.

```scheme
; This is not an application of define on two arguments
(define x 5)
```

## 1.1.4 Compound Procedures

This section covers functions and procedures.

```scheme
; Define a squaring function
(define (square x) (* x x))

; Invoking the square function with the argument 7 evaluates to 49
(square 7)
```

## 1.1.5 The Substitution Model for Procedure Application

This section explains how procedure application is substituted by its definition during evaluation.

```scheme
; Apply square on 4
(square 4)

; The expression is substituted with the body of square
(* 4 4)

; ... which evaluates to 16
```

It is noted that this is not to be taken as a description of how the interpreter really works under the hood but to provide us with a conceptual model of procedure application.

### Applicative order versus normal order

In *normal order evaluation* procedures are substituted before subexpressions are evaluated.

```scheme
; Normal order evaluation of the following expression
(square (+ 4 5))

; evaluates to
(* (+ 4 5) (+ 4 5))

; ... which reduces to
(* 9 9)

; ... and
81
```

This is not how the scheme interpeter works because it has to evaluate `(+ 4 5)` twice. Instead what it really uses is *applicative order evaluation*.

```scheme
; Normal order evaluation of the following expression
(square (+ 4 5))

; is reduced to
(square 9)

; which evaluates to
(* 9 9)

; ... and
81
```

Now the expression `(+ 4 5)` is only evaluated once. There are other consequences of this method that it is simpler to deal with when "we leave the realm of procedures that can be modeled by substitution." Effectful procedures, I'd guess.

It is stated that normal order evaluation has its uses and we will look into it more in chapter 3.

## 1.1.6 Conditional Expressions and Predicates

This section describe the control structures `if` and `cond`. `cond` being a `switch`-like expression found in other languages. It is noted that these are *special forms*.

```scheme
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))

; Evaluates to 7
(abs 7)

; Evaluates to 7
(abs -7)
```

`abs` can also be defined with an `if` expression.

```scheme
(define (abs x)
  (if (> x 0)
    x
    (- x)))

; Evaluates to 7
(abs 7)

; Evaluates to 7
(abs -7)
```

It is also explained how `and` and `or` can be used as control structures due to the truthyness and falsyness of values.

## 1.1.7 Example: Square Roots by Newton's Method

This section covers an example algorithm that I will not demonstrate here. A note on declarative vs imperative programming is brought up in comparing computer programs to mathematics.

Recursion is demonstrated for the first time.

```scheme
; f is defined in terms of itself
(define (f n)
  (if (> n 0)
    (+ n (f (- n 1)))
    0))

; invoked with 10 f evaluates to 55
(f 10)
```

## 1.1.8 Procedures as Black-Box Abstractions

I'd say this section is quite philosophical in nature. It explains that we should not worry too much about how a procedure solves a particular problem, only that it does. And that when exposing procedures we should hide procedures that we expect a client programmer (possibly ourselves) might not be interested in.

The section finishes off by demonstrating local definitions to hide these procedures.

```scheme
(define (sum-of-squares x)
  (define (sq x) (* x x))
  (+ (sq x) (sq x)))

(sum-of-squares 4)
```
