- [2.3 Symbolic Data](#23-symbolic-data)
  - [2.3.1  Quotation](#231-quotation)
  - [2.3.2  Example: Symbolic Differentiation](#232-example-symbolic-differentiation)
  - [2.3.3  Example: Representing Sets](#233-example-representing-sets)
  - [2.3.4  Example: Huffman Encoding Trees](#234-example-huffman-encoding-trees)

# 2.3 Symbolic Data

## 2.3.1  Quotation

This section shows how we can distinguish between symbols and their associated values.

```scheme
(define a 5)
(define b 4)

(list a b) ; yields the list (5 4)

(list 'a 'b) ; yields the list (a b)
```

An interesting aspect of LISP. I suspect the implications are significant. It seems like we can quote symbols that are not defined, ie associated with a value.

*I wonder if we can traverse code, analyse it and manipulate it symbolically! Can we do static analysis? Type systems? Effect systems? **drools***

As if hearing my internal thoughts, the book shows we can compare symbols with `eq?`. A peculiar procedure `memq` which is basically `any` with a slight twist. It looks for a symbol and if present, returns the rest of the list including the symbol.

It is a little bit too specific. I suspect there is special significance to this function so I'll resist the urge to implement my own version and implement the one in the book.

```scheme
(define (memq x xs)
  (cond ((null? xs) #f)
        ((eq? x (car xs)) xs)
        (else (memq x (cdr xs)))))

(memq 'apple '(pear banana prune)) ; #f

(memq 'apple '(pear apple banana prune)) ; (apple banana prune)
```

Again, the significance of this procedure escapes me but I'm sure it will be apparent later. I would personally implement it like this.

```scheme
(define (any? t xs)
  (cond ((null? xs) #f)
        ((t (car xs)) (car xs))
        (else (any? t (cdr xs)))))

(any? (lambda (x) (eq? x 'apple))
  '(pear apple banana prune)) ; apple
```

This is a little bit more Haskellish except I return the first matched result. I'm trying to resist thinking in Haskell or in any other language.

The following sections are fascinating but I'm moving on for now.

## 2.3.2  Example: Symbolic Differentiation

## 2.3.3  Example: Representing Sets

## 2.3.4  Example: Huffman Encoding Trees
