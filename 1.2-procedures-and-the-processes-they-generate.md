- [1.2  Procedures and the Processes They Generate](#12-procedures-and-the-processes-they-generate)
  - [1.2.1 Linear Recursion and Iteration](#121-linear-recursion-and-iteration)
    - [Linear recursion](#linear-recursion)
    - [Iteration](#iteration)
  - [1.2.2 Tree Recursion](#122-tree-recursion)
  - [1.2.3 Orders of Growth](#123-orders-of-growth)
  - [1.2.4 - 1.2.6](#124---126)

# 1.2  Procedures and the Processes They Generate

## 1.2.1 Linear Recursion and Iteration

This section describes two methods for calculating an accumulated value.

### Linear recursion

```scheme
(define (factorial n)
  (if (> n 1)
    (* n (factorial (- n 1)))
    1))

(factorial 5)
```

### Iteration

```scheme
(define (factorial n)
  (define (loop n acc)
    (if (> n 1)
      (loop (- n 1) (* acc n))
      acc))
  (loop n 1))

(factorial 6)
```

These two methods are equivalent except that the first version isn't tailrecursive. It could overflow the stack. The second one will not overflow the stack. It is also imperative and uses less memory.

## 1.2.2 Tree Recursion

Tree recursion is when a computation has to split into branching paths to produce a result. The fibonacci sequence is an example of this. Another could be traversing a branching data structure.

```scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(fib 7)
```

```scheme
(define (fib n)
  (define (loop a b n)
    (if (> n 0)
      (loop b (+ a b) (- n 1))
      a))
  (loop 0 1 n))

(fib 7)
```

Another two examples of a recursive version and an iterative version. The first one does double work under the hood.

## 1.2.3 Orders of Growth

This section talks about how a process grows in resource use. For example the recursive factorial grew linearly in steps (written O(n)) and grew linearly in space. This refers to a rough estimation in cpu and memory usage. The iterative factorial also grew linearly in steps but its space growth was constant (ie it didn't grow) (written O(1)).

## 1.2.4 - 1.2.6

- Exponentiation
- Greatest Common Divisors
- Example: Testing for Primality

The following sections shows how you can use mathematical insight to make more efficient code. I will not demonstrate them here because I don't find them very interesting right now.
