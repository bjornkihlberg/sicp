- [3.1  Assignment and Local State](#31-assignment-and-local-state)
  - [3.1.1  Local State Variables](#311-local-state-variables)
  - [3.1.2  The Benefits of Introducing Assignment](#312-the-benefits-of-introducing-assignment)
  - [3.1.3  The Costs of Introducing Assignment](#313-the-costs-of-introducing-assignment)

# 3.1  Assignment and Local State

This chapter compares impure object oriented style imperative programming with pure functional programming.

## 3.1.1  Local State Variables

This section demonstrates the `set!` special form for mutating definitions. It is fascinating that we're almost halfway through the book before this is even brought up.

```scheme
(define x 0)

(define (impure)
  (set! x (+ x 1))
  x)

(impure) ; 1
(impure) ; 2
(impure) ; 3
(impure) ; 4
```

This makes me uneasy and the book rightly explains that we lose the substitution model of evaluation.

Assignment is needed for certian problems but not nearly as much as it's currently used by most programmers.

In order to "encapsulate" the state of `x`, a "constructor" procedure is defined with a local mutable variable defined in its closure. The problem with this however is that the state is still global! We're merely giving the computer the ability to create more global state at runtime!

```scheme

(define (new-impure-object i)
  (let ((this-i i))
    (lambda ()
      (set! this-i (+ this-i 1))
      this-i)))

(define impure-object1 (new-impure-object 100))
(define impure-object2 (new-impure-object 100))

(impure-object1) ; 101
(impure-object1) ; 102
(impure-object1) ; 103
(impure-object2) ; 101
(impure-object2) ; 102
(impure-object1) ; 104
```

We can create an object that receives messages and performs mutations on itself.

```scheme
(define (new-object i)
  (define (increment x) (set! i (+ i x)))
  (define (decrement x) (set! i (- i x)))
  (define (dispatch m)
    (cond ((eq? 'increment (car m)) (increment (cdr m)))
          ((eq? 'decrement (car m)) (decrement (cdr m)))
          ((eq? 'get (car m)) i)))
  dispatch)

(define o (new-object 10))

(o (cons 'get '())) ; 10
(o (cons 'increment 3))
(o (cons 'increment 3))
(o (cons 'increment 4))
(o (cons 'decrement 1))
(o (cons 'get '())) ; 19
```

## 3.1.2  The Benefits of Introducing Assignment

This section explains how state can be useful in some cases. The example demonstrated here is a procedure `rand` producing random numbers with each call.

## 3.1.3  The Costs of Introducing Assignment

This section goes into the problems of having mutation in a computer language. Functional programming and imperative programming are compared.

- Referential transparency is an important aspect lost with the introduction of assignment.
- The problem of knowing if two objects are the same. They might have the same value but one can change and the other doesn't.
- The book also explains how reasoning about programs written in functional style can be easy, but becomes very hard when temporal complexity is introduced.
- Programs written in imperative style are susceptible to bugs that cannot occur in functional programs.
- The complexity of imperative programs becomes even worse if we consider applications in which several processes execute concurrently.
