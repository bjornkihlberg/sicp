- [2.4  Multiple Representations for Abstract Data](#24-multiple-representations-for-abstract-data)
  - [2.4.1  Representations for Complex Numbers](#241-representations-for-complex-numbers)
  - [2.4.2  Tagged data](#242-tagged-data)
  - [2.4.3  Data-Directed Programming and Additivity](#243-data-directed-programming-and-additivity)

# 2.4  Multiple Representations for Abstract Data

This chapter is quite interesting. I'm going to summarize it only. It talks about how sometime different underlying representations of data, can be equivalent but easier to work with in different situations.

## 2.4.1  Representations for Complex Numbers

Complex numbers are used as an example where they can either be represented in rectangular form or polar form. Addition and subtraction is simpler in rectangular form while multiplication and division is easier in polar form. Code using complex numbers need not concern itself with how they are represented.

## 2.4.2  Tagged data

Since both rectangular form and polar form can be represented with a pair of two numbers but with different meanings, how would a generic procedure operating on it know which representation is used? The book proposes to use a tag symbol associated with the pair in order to distinguish the meaning behind the numbers.

## 2.4.3  Data-Directed Programming and Additivity

This section describes a design pattern where you use a table to determine which procedure to call based on a given tag. This aims to solve the problem of a dynamic language lacking the ability to statically determine whether all cases of data are handled. Haskell for example doesn't have this problem because if a sum type has an extra case, code won't compile unless all match expressions also match against the new case.

I'm not fond of this. In my opinion design patterns are a symptom of a language lacking in power. I suspect however that this is a prelude to adding polymorphism to LISP. We'll see.

At the end of this section a couple of paragraphs are dedicated to "message passing" as a style of programming. Basically it seems to be explaining object oriented programming as it was originally concieved. The idea is that each piece of data has procedures associated with it and "knows" how that procedure should work.
